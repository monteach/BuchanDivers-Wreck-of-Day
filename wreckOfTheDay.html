<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
    <style>
        :root {
            --font-family: 'Lato', sans-serif;
            --title-color: rgba(34, 110, 147, 1);
            --text-color: black;
            --link-color: #3498db;
        }

        body {
            font-family: var(--font-family);
            margin: 20px;
            background-color: white; /* Stays white */
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            /* Removed align-items: center; to allow default left alignment for blocks */
        }

        h2.titleFormat {
            font-family: var(--font-family);
            font-size: 17px;
            font-weight: bold;
            color: var(--title-color);
            margin-bottom: 10px; /* Spacing below title */
            text-align: center; /* Changed back to center */
            max-width: 600px; /* Constrain width to match other content blocks */
            margin: 0 auto 10px auto; /* Centered the block itself with auto margins */
        }

        p.bodyFormat {
            font-family: var(--font-family);
            font-size: 15px;
            font-weight: normal;
            color: var(--text-color);
            line-height: 1.6;
            max-width: 600px; /* Constrain width for better reading */
            margin: 0 auto 15px auto; /* Center the block itself, text inside is left aligned */
            text-align: left; /* Left align the text within this block */
        }

        .imgContainer {
            width: 100%;
            max-width: 600px; /* Matched to text max-width */
            margin-bottom: 20px;
            overflow: hidden; /* Ensure image doesn't overflow container */
            border-radius: 8px; /* Rounded corners for image container */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow for image */
            margin: 0 auto; /* Ensures image is centered within imgContainer */
        }

        .imgFormat {
            max-width: 100%;
            max-height: 100%;
            height: auto; /* Maintain aspect ratio */
            display: block; /* Remove extra space below image */
            border-radius: 4px; /* Slightly rounded image corners */
            object-fit: cover; /* Cover the container without distortion if container has fixed height */
            margin: 0 auto; /* Ensures image is centered within imgContainer */
        }

        /* Styling for hyperlinks */
        a {
            color: var(--link-color);
            text-decoration: none;
            font-weight: bold;
        }

        a:hover {
            text-decoration: underline;
        }

        #loadingMessage {
            text-align: center;
            padding: 20px;
            font-size: 1.1em;
            color: #555;
        }

    </style>
    <title>Wreck of the Day</title>
</head>

<body>
    <h2 id="title" class="titleFormat">Loading...</h2>
    
    <div id="loadingMessage">Loading wreck data...</div>

    <div id="content" style="display: none;"> <!-- Content hidden until loaded -->
        <div class="imgContainer">
            <img id="wreckImage" class="imgFormat" alt="Wreck Image">
        </div>
        <p id="wreckText" class="bodyFormat"></p>
    </div>

<script>
    // Global helper function to parse a date string (expected dd-mmm-yyyy) into a Date object
    function parseDateString(date) {
        if (!date) return new Date(0); // Return epoch start for empty/null dates
        const months = {
            "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
            "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
            "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
        };
        const parts = date.split('-');
        if (parts.length === 3 && months[parts[1]]) {
            // Attempt to parse dd-mmm-yyyy
            const day = parts[0];
            const month = months[parts[1]];
            const year = parts[2];
            return new Date(`${year}-${month}-${day}`);
        }
        // Fallback for other formats or invalid dates
        return new Date(date); // This might return "Invalid Date" if the format is truly unparseable
    }

    // Function to format a Date object into dd-mmm-yyyy string (for display purposes)
    function formatDateToString(dateObj) {
        if (!(dateObj instanceof Date) || isNaN(dateObj.getTime())) {
            return ''; // Return empty string for invalid Date objects
        }
        const options = { day: '2-digit', month: 'short', year: 'numeric' };
        return dateObj.toLocaleDateString('en-GB', options); // 'en-GB' ensures dd/mm/yyyy structure, month: 'short' for mmm
    }

    // Base URL for your CSV data
    const baseCsvUrl = "https://storage.googleapis.com/buchan-divers-wreck-database/wreckDatabase.csv";
    const thumbnailBucketUrl = "https://storage.googleapis.com/buchan-divers-wreck-thumbnails/";
    
    let allWrecksData = []; // Store the parsed CSV data globally

    // Function to fetch and process CSV data
    async function loadWreckDataForWreckOfTheDay() {
        const loadingMessageElem = document.getElementById('loadingMessage');
        const contentElem = document.getElementById('content');
        const titleElem = document.getElementById('title');

        loadingMessageElem.style.display = 'block';
        contentElem.style.display = 'none';
        titleElem.textContent = "Loading...";

        try {
            // Append a timestamp to the CSV URL to bypass caching
            const csvUrlWithBuster = `${baseCsvUrl}?t=${new Date().getTime()}`;
            console.log(`Fetching wreck data for Wreck of the Day from: ${csvUrlWithBuster}`);

            const response = await fetch(csvUrlWithBuster);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP error fetching CSV! Status: ${response.status}, Details: ${errorText}`);
            }
            const csvText = await response.text();

            const lines = csvText.split('\n');
            if (lines.length < 2) {
                console.warn("CSV file is empty or only has a header.");
                loadingMessageElem.textContent = "No wreck data found.";
                return;
            }

            const headers = lines[0].split(',').map(header => header.trim());
            
            // Map headers to properties for easy access
            const colMap = {
                'Name': headers.indexOf('Name'),
                'Date of Loss': headers.indexOf('Date of Loss'),
                'Cause of Loss': headers.indexOf('Cause of Loss'),
                'Depth': headers.indexOf('Depth'),
                'WotD Comment': headers.indexOf('WotD Comment')
            };

            // Check for essential columns
            const essentialCols = ['Name', 'Date of Loss', 'WotD Comment']; 
            if (essentialCols.some(col => colMap[col] === -1)) {
                throw new Error(`Missing essential columns (${essentialCols.filter(col => colMap[col] === -1).join(', ')}) in CSV header.`);
            }

            allWrecksData = []; // Clear previous data
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Robust CSV parsing for lines that might contain commas within quoted fields
                const values = [];
                let inQuote = false;
                let currentField = '';
                for (let charIndex = 0; charIndex < line.length; charIndex++) {
                    const char = line[charIndex];

                    if (char === '"') {
                        inQuote = !inQuote;
                    } else if (char === ',' && !inQuote) {
                        values.push(currentField);
                        currentField = '';
                    } else {
                        currentField += char;
                    }
                }
                values.push(currentField); // Add the last field

                const trimmedValues = values.map(val => val.trim());

                const wreck = {};
                for (const key in colMap) {
                    if (colMap[key] !== -1 && trimmedValues[colMap[key]] !== undefined) {
                        wreck[key] = trimmedValues[colMap[key]];
                    } else {
                        wreck[key] = ''; // Ensure all properties exist, even if empty
                    }
                }

                // Filter out wrecks if 'WotD Comment' is blank (after trimming)
                if (wreck['WotD Comment'] && wreck['WotD Comment'].trim().length > 0) {
                    allWrecksData.push(wreck);
                } else {
                    // Changed to console.log to ensure visibility in the Canvas preview console
                    console.log(`Skipping wreck "${wreck.Name}" (WotD Comment blank/empty).`);
                }
            }

            displayWreckOfTheDay();

        } catch (error) {
            console.error("Error loading wreck data for Wreck of the Day:", error);
            loadingMessageElem.innerHTML = `<p style="color: red; padding: 20px;">
                <strong>Failed to load wreck data:</strong> ${error.message}.<br>
                Please ensure the CSV file exists in your Google Storage bucket and has public read access, or that CORS is configured correctly.
                Also, verify that the 'WotD Comment' column exists in your CSV and contains content for wrecks you wish to display.
            </p>`;
        } finally {
            loadingMessageElem.style.display = 'none'; // Hide loading message
            contentElem.style.display = 'block'; // Show content
        }
    }

    // Function to find and display the wreck of the day
    function displayWreckOfTheDay() {
        if (allWrecksData.length === 0) {
            document.getElementById("title").textContent = "No Wreck Data Available";
            document.getElementById("wreckText").textContent = "No wrecks with comments found in the database (after filtering).";
            document.getElementById("wreckImage").src = `https://placehold.co/400x300/EEEEEE/AAAAAA?text=No+Image`;
            return;
        }

        const today = new Date();
        const currentDay = today.getDate();
        // getMonth() returns 0-11, so add 1 for 1-12
        const currentMonth = today.getMonth() + 1; 
        const currentYear = today.getFullYear();
        
        let selectedWreck = null;
        let isAnniversary = false;

        // Try to find a wreck with an anniversary today
        // All wrecks in allWrecksData now have a WotD Comment
        const wrecksWithValidDates = allWrecksData.filter(wreck => {
            const lossDate = parseDateString(wreck['Date of Loss']);
            return !isNaN(lossDate.getTime());
        });

        for (let i = 0; i < wrecksWithValidDates.length; i++) {
            const wreck = wrecksWithValidDates[i];
            const lossDate = parseDateString(wreck['Date of Loss']);

            if (lossDate.getDate() === currentDay && (lossDate.getMonth() + 1) === currentMonth) {
                selectedWreck = wreck;
                isAnniversary = true;
                break; // Found an anniversary, use this one
            }
        }

        if (!selectedWreck) {
            // If no anniversary, pick one based on day of year
            // Ensure we pick from wrecks with valid dates if available (though allWrecksData now only contains valid comments)
            const wrecksToChooseFrom = wrecksWithValidDates.length > 0 ? wrecksWithValidDates : allWrecksData;
            
            if (wrecksToChooseFrom.length === 0) {
                document.getElementById("title").textContent = "No Wreck Data Available";
                document.getElementById("wreckText").textContent = "No wrecks with comments or valid dates found in the database (after filtering).";
                document.getElementById("wreckImage").src = `https://placehold.co/400x300/EEEEEE/AAAAAA?text=No+Image`;
                return;
            }

            const startOfYear = new Date(currentYear, 0, 0);
            const diff = today - startOfYear;
            const oneDay = 1000 * 60 * 60 * 24;
            const dayOfYear = Math.floor(diff / oneDay);
            
            selectedWreck = wrecksToChooseFrom[dayOfYear % wrecksToChooseFrom.length];
        }

        // Prepare content for display
        const wreckName = selectedWreck.Name || 'Unnamed Wreck';
        
        // Get the WotD Comment (guaranteed to be non-blank now)
        const displayComment = selectedWreck['WotD Comment'];

        // Construct URL for the wreck page
        const wreckPageNameForUrl = wreckName.replace(/[\s.]+/g, '-').toLowerCase();
        const wreckPageUrl = `https://www.buchandivers.com/wrecks/${wreckPageNameForUrl}`;

        // Construct URL for the image
        const wreckImageFilename = encodeURIComponent(wreckName) + '.jpg';
        const imageUrl = `${thumbnailBucketUrl}${wreckImageFilename}`;
        const placeholderImageUrl = `https://placehold.co/400x300/EEEEEE/AAAAAA?text=No+Image`; // Larger placeholder

        // Update the HTML elements
        const titleElem = document.getElementById("title");
        const wreckTextElem = document.getElementById("wreckText");
        const wreckImageElem = document.getElementById("wreckImage");

        if (isAnniversary) {
            titleElem.innerHTML = `Wrecked on this day: <a href="${wreckPageUrl}" target="_blank">${wreckName}</a>`;
        } else {
            titleElem.innerHTML = `Wreck of the day: <a href="${wreckPageUrl}" target="_blank">${wreckName}</a>`;
        }
        
        wreckTextElem.innerHTML = displayComment; // Use the WotD Comment (no fallback needed now)

        wreckImageElem.src = imageUrl;
        wreckImageElem.onerror = function() {
            console.error(`Failed to load image: ${imageUrl}. Using placeholder.`);
            this.onerror = null; // Prevent infinite loop if placeholder also fails
            this.src = placeholderImageUrl;
        };

        console.log(`Image URL for Wreck of the Day: ${imageUrl}`);
    }

    // Load data when the window loads
    window.addEventListener('load', loadWreckDataForWreckOfTheDay);

</script>
</body>
</html>


